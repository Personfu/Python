============================================================
FLLC Enterprise IT — Phase 05: Core Algorithm Library
CIS 275 — Data Structures & Algorithms | Preston Furulie
============================================================

PHASE SUMMARY
─────────────
Four production-quality algorithm implementations with full
complexity analysis and benchmarking. These form the
computational backbone of FLLC enterprise applications.

============================================================
Deliverable 1: Linked List Library
File: linked_list.py (330+ lines)
============================================================

Singly Linked List (15 operations):
  - prepend(data): O(1) — insert at head
  - append(data): O(n) — insert at tail
  - insert_at(index, data): O(n) — positional insert
  - insert_sorted(data): O(n) — maintain sorted order
  - delete_first(): O(1) — remove head
  - delete_last(): O(n) — remove tail
  - delete_value(data): O(n) — remove first match
  - delete_at(index): O(n) — positional delete
  - search(data): O(n) — return index or -1
  - contains(data): O(n) — boolean check
  - get_at(index): O(n) — retrieve by position
  - length: O(n) — count nodes
  - reverse(): O(n) — in-place reversal
  - find_middle(): O(n) — slow/fast pointer technique
  - has_cycle(): O(n) — Floyd's cycle detection
  - remove_duplicates(): O(n²) — eliminate duplicate values
  - __iter__: iterator protocol support

Doubly Linked List:
  - Node with prev and next pointers
  - O(1) append via tail reference
  - Bidirectional traversal

============================================================
Deliverable 2: Binary Search Tree
File: binary_search_tree.py (250+ lines)
============================================================

Operations:
  - insert(value): iterative, handles duplicates with count
  - search(value): O(log n) average, O(n) worst
  - delete(value): 3 cases (leaf, one child, two children)
  - find_min() / find_max(): O(log n) average

Traversals:
  - in_order: sorted output (Left → Root → Right)
  - pre_order: tree copy (Root → Left → Right)
  - post_order: deletion safe (Left → Right → Root)
  - level_order: BFS with queue (breadth-first)

Analysis:
  - height(): tree depth calculation
  - is_balanced(): |left_height - right_height| ≤ 1
  - is_valid_bst(): structural integrity check
  - count_nodes(): total node count
  - print_tree(): ASCII visualization

============================================================
Deliverable 3: Sorting Algorithms
File: sorting_algorithms.py (210+ lines)
============================================================

Algorithms Implemented:
  1. Bubble Sort     — O(n²) avg, O(1) space, stable
  2. Selection Sort  — O(n²) all, O(1) space, unstable
  3. Insertion Sort  — O(n²) avg, O(1) space, stable
  4. Merge Sort      — O(n log n) all, O(n) space, stable
  5. Quick Sort      — O(n log n) avg, O(log n) space, unstable
  6. Counting Sort   — O(n+k) all, O(k) space, stable
  7. Python Timsort  — O(n log n) avg, used by sorted()

Features:
  - Each function includes docstring with complexity
  - Operation counter for empirical comparison
  - Benchmarking framework: random data generation, timing
  - Complexity reference table in output

============================================================
Deliverable 4: Graph Traversal Engine
File: graph_traversal.py (310+ lines)
============================================================

Graph Class (adjacency list):
  - Support for directed and undirected graphs
  - Weighted and unweighted edge support
  - add_vertex(), add_edge(), get_neighbors()

BFS (Breadth-First Search):
  - Standard traversal: O(V+E)
  - Unweighted shortest path
  - Level-order traversal (distance from source)

DFS (Depth-First Search):
  - Recursive implementation
  - Iterative implementation (explicit stack)
  - Find all paths between two vertices

Advanced Algorithms:
  - Dijkstra's shortest path (weighted, O((V+E) log V))
  - Topological sort (Kahn's algorithm, DAG only)
  - Cycle detection:
    - Directed graphs: 3-color marking (WHITE/GRAY/BLACK)
    - Undirected graphs: parent-tracking DFS
  - Connected components (undirected graphs)

============================================================
END OF PHASE 05 — CORE ALGORITHM LIBRARY
============================================================
